import type { Pointer, XmlAttrPtr, XmlDocPtr, XmlNodePtr, XmlNsPtr, XmlOutputBufferPtr, XmlParserCtxtPtr, XmlXPathCompExprPtr, XmlXPathContextPtr } from './libxml2raw.cjs';
import { ContextStorage } from './utils.mjs';
/**
 * The base class for exceptions in this library.
 *
 * All exceptions thrown in this library will be instances of this class or its subclasses.
 */
export declare class XmlError extends Error {
}
export interface ErrorDetail {
    /**
     * The error message during processing.
     */
    message: string;
    /**
     * The name of the XML file in which the error occurred.
     */
    file?: string;
    /**
     * The line number in the xml file where the error occurred.
     */
    line: number;
    /**
     * The column number in the XML file where the error occurred.
     */
    col: number;
}
/**
 * An exception class represents the error in libxml2.
 */
export declare class XmlLibError extends XmlError {
    /**
     * The detail of errors provided by libxml2.
     */
    details: ErrorDetail[];
    constructor(message: string, details: ErrorDetail[]);
}
export declare function xmlReadString(ctxt: XmlParserCtxtPtr, xmlString: string, url: string | null, encoding: string | null, options: number): XmlDocPtr;
export declare function xmlReadMemory(ctxt: XmlParserCtxtPtr, xmlBuffer: Uint8Array, url: string | null, encoding: string | null, options: number): XmlDocPtr;
export declare function xmlXPathRegisterNs(ctx: XmlXPathContextPtr, prefix: string, uri: string): number;
export declare function xmlHasNsProp(node: XmlNodePtr, name: string, namespace: string | null): XmlAttrPtr;
export declare function xmlSetNsProp(node: XmlNodePtr, namespace: XmlNsPtr, name: string, value: string): XmlAttrPtr;
export declare function xmlNodeGetContent(node: XmlNodePtr): string;
export declare function xmlNodeSetContent(node: XmlNodePtr, content: string): number;
export declare function xmlGetNsList(doc: XmlDocPtr, node: XmlNodePtr): XmlNsPtr[];
export declare function xmlSearchNs(doc: XmlDocPtr, node: XmlNodePtr, prefix: string | null): XmlNsPtr;
export declare function xmlXPathCtxtCompile(ctxt: XmlXPathContextPtr, str: string): XmlXPathCompExprPtr;
export declare namespace error {
    const storage: ContextStorage<ErrorDetail[]>;
    const errorCollector: number;
}
export declare class XmlXPathObjectStruct {
    static type: (ptr: number) => number;
    static nodesetval: (ptr: number) => number;
    static boolval: (ptr: number) => number;
    static floatval: (ptr: number) => number;
    static stringval: (ptr: number) => string;
}
export declare namespace XmlXPathObjectStruct {
    enum Type {
        XPATH_NODESET = 1,
        XPATH_BOOLEAN = 2,
        XPATH_NUMBER = 3,
        XPATH_STRING = 4
    }
}
export declare class XmlNodeSetStruct {
    static nodeCount: (ptr: number) => number;
    static nodeTable(nodeSetPtr: Pointer, size: number): Int32Array;
}
export declare class XmlTreeCommonStruct {
    static type: (ptr: number) => number;
    static name_: (ptr: number) => string;
    static children: (ptr: number) => number;
    static last: (ptr: number) => number;
    static parent: (ptr: number) => number;
    static next: (ptr: number) => number;
    static prev: (ptr: number) => number;
    static doc: (ptr: number) => number;
}
export declare class XmlNamedNodeStruct extends XmlTreeCommonStruct {
    static namespace: (ptr: number) => number;
}
export declare class XmlNodeStruct extends XmlNamedNodeStruct {
    static properties: (ptr: number) => number;
    static nsDef: (ptr: number) => number;
    static line: (ptr: number) => number;
}
export declare namespace XmlNodeStruct {
    enum Type {
        XML_ELEMENT_NODE = 1,
        XML_ATTRIBUTE_NODE = 2,
        XML_TEXT_NODE = 3,
        XML_CDATA_SECTION_NODE = 4,
        XML_COMMENT_NODE = 8
    }
}
export declare class XmlNsStruct {
    static next: (ptr: number) => number;
    static href: (ptr: number) => string;
    static prefix: (ptr: number) => string;
}
export declare class XmlAttrStruct extends XmlTreeCommonStruct {
}
export declare class XmlErrorStruct {
    static message: (ptr: number) => string;
    static file: (ptr: number) => string | null;
    static line: (ptr: number) => number;
    static col: (ptr: number) => number;
}
export declare function xmlNewCDataBlock(doc: XmlDocPtr, content: string): XmlNodePtr;
export declare function xmlNewDocComment(doc: XmlDocPtr, content: string): XmlNodePtr;
export declare function xmlNewDocNode(doc: XmlDocPtr, ns: XmlNsPtr, name: string): XmlNodePtr;
export declare function xmlNewDocText(doc: XmlDocPtr, content: string): XmlNodePtr;
export declare function xmlNewNs(node: XmlNodePtr, href: string, prefix?: string): XmlNsPtr;
/**
 * The input provider for Virtual IO.
 *
 * This interface defines four callbacks for reading the content of XML files.
 * Each callback takes a 4-byte integer as the type of file descriptor.
 *
 * @see {@link xmlRegisterInputProvider}
 * @alpha
 */
export interface XmlInputProvider {
    /**
     * Determine if this input provider should handle this file.
     * @param filename The file name/path/url
     * @returns true if the provider should handle it.
     */
    match(filename: string): boolean;
    /**
     * Open the file and return a file descriptor (handle) representing the file.
     * @param filename The file name/path/url
     * @returns undefined on error, number on success.
     */
    open(filename: string): number | undefined;
    /**
     * Read from the file.
     * @param fd File descriptor
     * @param buf Buffer to read into, with a maximum read size of its byteLength.
     * @returns number of bytes actually read, -1 on error.
     */
    read(fd: Pointer, buf: Uint8Array): number;
    /**
     * Close the file.
     * @param fd File descriptor
     * @returns `true` if succeeded.
     */
    close(fd: Pointer): boolean;
}
/**
 * Register the callbacks from the provider to the system.
 *
 * @param provider Provider of callbacks to be registered.
 * @alpha
 */
export declare function xmlRegisterInputProvider(provider: XmlInputProvider): boolean;
/**
 * Remove and cleanup all registered input providers.
 * @alpha
 */
export declare function xmlCleanupInputProvider(): void;
/**
 * Callbacks to process the content in the output buffer.
 */
export interface XmlOutputBufferHandler {
    /**
     * The function that gets called when the content is consumed.
     * @param buf The buffer that holds the output data.
     *
     * @returns The bytes had been consumed or -1 on errors
     */
    write(buf: Uint8Array): number;
    /**
     * The callback function that will be triggered once all the data has been consumed.
     *
     * @returns Whether the operation is succeeded.
     */
    close(): boolean;
}
export declare function xmlOutputBufferCreate(handler: XmlOutputBufferHandler): XmlOutputBufferPtr;
export declare function xmlSaveFormatFileTo(buf: XmlOutputBufferPtr, doc: XmlDocPtr, encoding: string | null, format: number): number;
export declare const xmlAddChild: (parent: number, cur: number) => number;
export declare const xmlAddNextSibling: (prev: number, cur: number) => number;
export declare const xmlAddPrevSibling: (next: number, cur: number) => number;
export declare const xmlCtxtSetErrorHandler: (ctxt: number, handler: number, data: number) => void;
export declare const xmlDocGetRootElement: (doc: number) => number;
export declare const xmlDocSetRootElement: (doc: number, root: number) => number;
export declare const xmlFreeDoc: (Doc: number) => void;
export declare const xmlFreeNode: (node: number) => void;
export declare const xmlFreeParserCtxt: (ctxt: number) => void;
export declare const xmlGetLastError: () => number;
export declare const xmlNewDoc: () => number;
export declare const xmlNewParserCtxt: () => number;
export declare const xmlRelaxNGFree: (schema: number) => void;
export declare const xmlRelaxNGFreeParserCtxt: (ctxt: number) => void;
export declare const xmlRelaxNGFreeValidCtxt: (ctxt: number) => void;
export declare const xmlRelaxNGNewDocParserCtxt: (doc: number) => number;
export declare const xmlRelaxNGNewValidCtxt: (schema: number) => number;
export declare const xmlRelaxNGParse: (ctxt: number) => number;
export declare const xmlRelaxNGSetParserStructuredErrors: (ctxt: number, handler: number, data: number) => void;
export declare const xmlRelaxNGSetValidStructuredErrors: (ctxt: number, handler: number, data: number) => void;
export declare const xmlRelaxNGValidateDoc: (ctxt: number, doc: number) => number;
export declare const xmlRemoveProp: (cur: number) => number;
export declare const xmlResetLastError: () => void;
export declare const xmlSchemaFree: (schema: number) => void;
export declare const xmlSchemaFreeParserCtxt: (ctx: number) => void;
export declare const xmlSchemaFreeValidCtxt: (ctx: number) => void;
export declare const xmlSchemaNewDocParserCtxt: (doc: number) => number;
export declare const xmlSchemaNewValidCtxt: (schema: number) => number;
export declare const xmlSchemaParse: (ctx: number) => number;
export declare const xmlSchemaSetParserStructuredErrors: (ctx: number, handler: number, data: number) => void;
export declare const xmlSchemaSetValidStructuredErrors: (ctx: number, handler: number, data: number) => void;
export declare const xmlSchemaValidateDoc: (ctx: number, doc: number) => number;
export declare const xmlSetNs: (node: number, ns: number) => void;
export declare const xmlUnlinkNode: (cur: number) => void;
export declare const xmlXIncludeFreeContext: (ctx: number) => void;
export declare const xmlXIncludeNewContext: (doc: number) => number;
export declare const xmlXIncludeProcessNode: (ctxt: number, node: number) => number;
export declare const xmlXIncludeSetErrorHandler: (ctxt: number, handler: number, data: number) => void;
export declare const xmlXPathCompiledEval: (comp: number, ctx: number) => number;
export declare const xmlXPathFreeCompExpr: (comp: number) => void;
export declare const xmlXPathFreeContext: (context: number) => void;
export declare const xmlXPathFreeObject: (obj: number) => void;
export declare const xmlXPathNewContext: (doc: number) => number;
export declare const xmlXPathSetContextNode: (node: number, ctx: number) => number;
